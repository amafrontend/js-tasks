import {test} from "./tester.js"

/** ЗАДАЧА:
 * Офис X работает по правилам коворкинга:
 * каждый сотрудник может работать из дома или приходить в офис.
 * 
 * В спокойные дни в офисе тихо, приходят пара-тройка людей.
 * А ближе к релизам/отчётным периодам/другим завалам людей гораздо больше,
 * но все сотрудники всё равно никогда не выходят.
 * 
 * Начальство хочет какое-то время понаблюдать, сколько же человек максимум приходят в офис,
 * чтобы сократить количество «посадочных мест» и меньше платить за аренду.
 * Для этого они наладили систему, которая фиксирует время захода и выхода людей из офиса,
 * и планируют из этих данных получить максимальное количество присутствующих сотрудников в день.
 * 
 * Система сохраняет данные в формате [времяВхода, времяВыхода] для каждого сотрудника.
 * Если люди входят и выходят одновременно, считается, что выход происходит раньше
 * (уходящий человек уже встал с места и освободил его, а входящий ещё не успел занять).
 * 
 * Ваша задача — написать функцию, получающую из информации в системе
 * максимальное количество одновременно находящихся сотрудников в офисе.
 */

/* Примеры:
count([]) // 0
count([[1, 5], [5, 10]]) // 1
count([[1, 5], [0, 1], [4, 5]]) // 2
count([[1, 10], [5, 6], [2, 3], [7, 8]]) // 2
count([[1, 2], [1, 10], [4, 9], [8, 15], [5, 6], [8, 16]]) // 4
*/

/** Дополнение:
 * По мере пропуска людей через турникеты на входе
 * можно просто вести учёт людей, находящихся в офисе
 * в каждый конкретный момент времени.
 * 
 * Если человек заходит, прибавляем к текущему числу единицу,
 * выходит — отнимаем.
 * 
 * Охраннику всё равно,
 * входил в этот момент Паша, Игорь или Женя.
 * Ему важно, что кто-то когда-то вошёл,
 * а кто-то когда-то вышел.
 * 
 * Он не связывает эти события в пары, как это делает система.
 * Тогда и максимум можно обновлять по мере продвижения людей:
 * если вошло больше людей, чем было до этого, обновляем, если нет — не трогаем. 
 */

function compareEntries(left, right) {
  // Выход раньше входа в то же время
  if (left.time === right.time) {
    return left.isEntering ? 1 : -1;
  }

  return left.time - right.time;
}

function count(input) {
  const entries = [];

  for (const [enteringTime, leavingTime] of input) {
    entries.push({
      time: enteringTime,
      isEntering: true,
    });

    entries.push({
      time: leavingTime,
      isEntering: false,
    })
  }

  entries.sort(compareEntries);

  let currentCount = 0;
  let maximumCount = 0;

  for (const {isEntering} of entries) {
    currentCount += isEntering ? 1 : -1;

    // накапливаем одновременное нахождение людей в офисе
    maximumCount = Math.max(currentCount, maximumCount);
  }

  return maximumCount;
}

test(count([]), 0)
test(count([[1, 5], [5, 10]]), 1)
test(count([[1, 5], [0, 1], [4, 5]]), 2)
test(count([[1, 10], [5, 6], [2, 3], [7, 8]]), 2)
test(count([[1, 2], [1, 10], [4, 9], [8, 15], [5, 6], [8, 16]]), 4)
