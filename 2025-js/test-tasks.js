// Тест

// #1
// Какой из массивов НЕ будет выведен после выполнения этого кода?
let fruits = ["Яблоко", "Апельсин", "Слива"];
const fruits1 = ["Яблоко", "Апельсин", "Слива"];
fruits1[0]= "Мандарин";
function test() {
  const fruits1 = ["Малина", "Клубника", "Смородина"];
  let fruits2 = ["Груша", "Крыжовник", "Агрэст"];
  fruits2[0]= "Мандарин";
  console.log(fruits);
}
test();
console.log(fruits1);
console.log(fruits);

// Варианты ответов
// ["Малина", "Клубника", "Смородина"]
// Будут выведены все массивы
// [ 'Мандарин', 'Крыжовник', 'Агрэст' ]
// [ 'Мандарин', 'Апельсин', 'Слива' ]
// [ 'Яблоко', 'Апельсин', 'Слива' ]

// #2
// Задача. Перед вами поставили задачу написать веб-приложение крестики-нолики. По техническому заданию вам необходимо сохранять состояние игры. Например, вы можете сохранить текущего игрока, расположение крестиков и ноликов на игровом поле и другие данные, чтобы игра могла быть возобновлена после перезагрузки страницы. Какой тип хранилища вы подберете для данной задачи?

// Перед вами поставили задачу написать веб-приложение крестики-нолики.
// По техническому заданию вам необходимо сохранять состояние игры.
// Например, вы можете сохранить текущего игрока, 
// расположение крестиков и ноликов на игровом поле
// и другие данные, чтобы игра могла быть возобновлена после перезагрузки страницы.
// Какой тип хранилища вы подберете для данной задачи?

// Варианты ответов
// sessionStorage
// Cache API
// Web SQL Database
// LocalStorage
// Куки (cookies)

// #3
// Каким будет результат выполнения следующего выражения в JavaScript?
// "10"+2*"5"

// Варианты ответов
// 100
// 20
// 1010
// 50
// 1055

// #4
// Из массива чисел вам нужно сначала отфильтровать четные числа, затем удвоить их и, наконец, вычислить сумму. Какой код это выполняет?
const numbers = [1,2,3,4];

// Варианты ответов
// numbers.reduce((sum, n) => sum + n).map(n => n * 2).filter(n => n % 2 === 0);
// numbers.filter(n => n % 2 === 0).map(n => n * 2).reduce((sum, n) => sum + n, 0); // Правильный
// numbers.reduce((sum, n) => sum + n * 2, 0).filter(n => n % 2 === 0);
// numbers.map(n => n * 2).filter(n => n => n % 2 === 0).reduce((sum, n) => sum + n);
// numbers.filter(n => n % 2).map(n => n + 2).reduce((sum, n) => sum);

// #5
// Какая из функций предназначена для создания объектов с заданными свойствами и методами?

// Варианты ответов
// функция-конструктор (constructor function)
// генераторная функция (generator function)
// стрелочная функция (arrow function)
// рекурсивная функция (recursive function)
// функция обратного вызова (callback)

// #6
// Что будет выведено в консоли при выполнении данного кода
function counter() {
  var count = 0;
  return function() {
    return ++count;
  }
}

var increment = counter();

console.log(increment());
console.log(increment());
console.log(increment());

// Варианты ответов
// 2,3,4
// 1,1,1
// 1,2,3
// 0,1,2
// 0,0,0

// #7
// В какой последовательности выполняются операции в следующем коде, который включает асинхронные операции и взаимодействие с сетью? Учтите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.
console.log("Начало");

setTimeout(() => {
  console.log("SetTimeout 1");
}, 0);

fetch("https://api.example.com/data")
  .then(response => response.json())
  .then(data => {
    console.log("Данные получены:", data);
  });

setTimeout(() => {
  console.log("SetTimeout 2");
}, 0);

console.log("Конец");

// Варианты ответов
// Начало, Конец, SetTimeout 1, Данные получены: [данные], SetTimeout 2
// Начало, SetTimeout 1, SetTimeout 2, Конец, Данные получены: [данные]
// Начало, Конец, Данные получены: [данные], SetTimeout 1, SetTimeout 2
// Конец, Начало, SetTimeout 1, SetTimeout 2, Данные получены: [данные]
// Начало, Конец, SetTimeout 1, SetTimeout 2, Данные получены: [данные]

// #8
// Какое из следующих утверждений о конструкции Map в JavaScript является верным?

// Варианты ответов
// Map не позволяет использовать объекты в качестве ключей.
// Метод Delete в Map возвращает удаляемые элементы из коллекции.
// Map автоматически сортирует свои элементы по возрастанию ключей.
// Ключи в Map могут быть только строками.
// Map гарантирует, что элементы будут храниться в порядке добавления.

// #9
// Вам нужно создать неглубокую копию объекта и массива в JavaScript. При этом важно сохранить методы, определенные в самом объекте, без учета прототипной цепочки. Какой из следующих методов или подходов вы выберете?

// Варианты ответов
// const newObj = {...obj}, newArr = [...arr]
// const newObj = Object.assing(obj), newArr = Array.copy(arr)
// const newObj = new Object(obj), newArr = new Array(arr)
// const newObj = JSON.parse(JSON.stringify(obj)), newArr = JSON.parse(JSON.stringify(arr))
// const newObj = obj, newArr = arr

// #10
// У вас есть следующий код, что будет выведено в консоль при его вызове.

class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise`)
  }
}

class Dog extends Animal {
  speak() {
    super.speak();
    console.log(`${this.name} barks.`)
  }
}

let dog = new Dog("Rex");
dog.speak();

// Варианты ответов
// В консоли будет выведено только "Rex barks" и затем "елочки"
// В консоли ничего не будет выведено, так как метод speak() переопределен в классе Dog
// В консоли будет выведено только "Dog makes a noise" и затем "Dog barks"
// Произойдет ошибка из-за вызова super.speak()
// В консоли будет выведено только "Rex makes a noise" и затем "Rex barks"

// #11
// Вы разрабатываете интерфейс для интернет-магазина, который должен содержать витрину для тысяч товаров. Какой подход стоит использовать, чтобы обеспечить плавное и быстрое отображение этих товаров при прокрутке и избежать задержек и зависания интерфейса?

// Варианты ответов
// Привести оптимизацию запросов к серверу через WebSockets для непрерывной загрузки данных о товарах.
// Применение техники "Debounce" для событий прокрутки.
// Применить "ленивую загрузку" для изображения товаров.
// Использовать кэширование данных на стороне клиента.
// Реализовать виртуальный скроллинг для отображения товаров в текущем viewport (видимой области) браузера.

// #12
// Проанализируйте фрагмент кода и определите порядок, в котором сообщения будут выведены в консоль.

// Варианты ответов
console.log("1");

setTimeout(() => {
  console.log("2");
  Promise.resolve().then(function() {
    console.log("3");
  })
}, 0);

Promise.resolve().then(function() {
  console.log("4");
  setTimeout(() => {
    console.log("5");
  }, 0);
})

// fetch("https://api.example.com/data")
//   .then(response => response.json())
//   .then(data => {
//     console.log("Данные получены:", data);
//   });

requestAnimationFrame(function() {
  console.log("7");
});

console.log("6");

// Варианты ответов
// 1,4,6,7,2,5,3
// 1,6,4,2,3,5,7
// 1,2,4,6,5,7,3
// 1,4,6,2,3,7,5
// 1,6,4,2,7,5,3

// #13
// Для чего применяется 3Shaking в системах сборки JavaScript на прикладном уровне?

// Варианты ответов
// Для шифрования и обфускации JavaScript-кода с целью защиты интеллектуальной собственности.
// Для автоматического определения и удаления неиспользуемого кода во время сборки.
// Для асинхронного выполнения функций с использованием деревьев вызовов (сall trees).
// Для отображения и визуализации иерархической структуры DOM-элементов веб-страницы.
// Для создания иерархии древовидной структуры данных в JavaScript-приложениях.

// #14
// Как добавить новый элемент в дом с помощью JavaScript после загрузки страницы?
// Варианты ответов
// Используя комбинацию методов document.create() и document.append()
// Используя комбинацию методов document.createElement() и document.appendChild() // ?
// Использую метод document.createAndInsertElement()
// Использую комбинацию методов document.createElm() и document.insert()

// #15
// Вы работаете над SPA, Single Page Application, которая активно обращается к API для обработки действий пользователя и вывода изменяющегося контента. Ваша задача – увеличить производительность приложений и сократить время полной первой отрисовки страницы. У вас в наличии мощный сервер, вы не ограничены пропускной способностью сетевого оборудования. Какой метод вы используете для достижения этой цели?
// Варианты ответов
// Serial-side Rendering (SSR)
// Техники Throttling и Debouncing
// Web workers
// Техника Lazy Loading // ?
// Кеширование ответов от API в local storage
